# ----운영체제(OS)를 배우기 앞서----
> - 컴퓨터 H/W위에 설치되어 사용자 및 모든 S/W와 H/W를 연결하는 소프트웨어계층<br>
> - 좁은의미 = 커널(운영체제 핵심부분, 부팅 이후 메모리에 상주하는 부분)<br>
> - 넓은의미 = 커널 + 각종 주변 시스템 유틸리티<br>
### 목적
- 자원을 효율적으로 관리
    - 자원 : CPU, 기억장치, 입출력장치...
    - H/W, S/W 자원 모두 관리
- 사용자가 편리하게 사용할 수 있는 환경 제공
- 효율성, 형평성 둘 다 고려
### 분류
- 동시작업 가능여부
    - 단일작업
        - 하나에 1개 작업처리
        - MS-DOS
    - 다중작업
        - 동시에 2개 이상 작업처리
- 사용자 수
    - 단일
    - 다중
- 처리방식
    - 일괄(batch)
        - 작업 일정량을 모아서 한꺼번에 처리
        - 작업이 완전 종료될 때까지 대기
    - 시분할(time sharing)
        - 사람이 느끼기에 빠르게하면서 주어진 자원을 최대한 활용 ---> 정확한 시간을 맞추지는 않음
        - 여러작업 수행시 일정 시간 단위로 분할하여 사용
        - 일괄처리에 비해 짧은 응답시간
        - interactive 방식
            - 내가 입력하는대로 화면에서 볼 수 있음
        - 범용 컴퓨터
    - 실시간(realtime)
        - deadline 존재
        - 정해진 시간안에 일을 종료
        - 특수목적을 가진 시스템에서 사용
        - 종류
            - hard
                - 정해진 시간을 지키지 않으면 치명적인 결과 발생 
                - ex) 반도체 공장
            - soft 
                - 사람이 불편함을 느낄 수는 있지만 치명적인 결과 발생X 
                - ex) 영화보기
### 예시
    - 유닉스
        - 대형컴퓨터를 위해 개발
        - multitasking, multiuser로 시작
        - 대부분 C언어로 작성 ---> 공개
        - 높은 이식성
        - 최소한의 커널을 가짐
        - 
    - MS-DOS
        - 단일작업용 운영체제
        - 주기억장치 제한 = max 640KB
    - windows
        - 개인 컴퓨터를 위해 개발
        - singletasking, singleuser로 시작
        - 다중 작업용 GUI 기반 운영체제
```
<용어정리>
- 비슷한 용어들
1. multitasking - 하나의 프로그램이 종료되기 전에 다른 프로그램 실행 가능
2. multiprogrammingn - 메모리에 여러 프로그램이 동시에 올라감(메모리 측면 강조)
3. time sharing - CPU 시간 분할해서 사용(CPU 강조)
4. multiprocess - 여러 프로그램 동시 실행

- 다른 용어
1. multiprocessor - 1:N = 컴퓨터:CPU ----> 각각 하드웨어적으로 다름
```
### 구조
- CPU 스케줄링
    - 누구한테 CPU를 줄까?
- 메모리 관리
    - 한정된 메모리를 어떻게 쪼개어 쓰지?
- 파일 관리
    - 디스크에 파일을 어떻게 보관하지?
    - 스케줄링 필요
- 입출력 관리
    - 각기 다른 I/O장치와 컴퓨터 간에 어떻게 정보를 주고 받게 하지?
- 프로세스 관리
    - 프로세스 생성, 삭제
    - 자원할당 및 반환
    - 프로세스 간 협력
- 그 외
    - 보호 시스템
    - 네트워킹
    - 명령어 해독기

---
# ----컴퓨터 시스템 구조----
- 로컬 버퍼 : I/O 장치마다 처리하는 공간
- I/O 체제는 운영체제만 접근 가능
- mode bit
    - 1: 사용자 모드 --> 사용자 프로그램이 CPU를 가지고 있을 때 제한된 instruction만 사용 가능
    - 0 : 모니터 모드(커널 모드) --> 운영체제가 CPU를 가지고 있을 때 모든 접근 가능
- timer(타이머)
    - H/W
    - 특정 프로그램이 독점하는 것을 막기 위해 타이머에 정적 시간을 설정해서 제어권을 넘김
    - 제한된 시간이 지나면 인터럽트를 해서 CPU를 뺏을 수 있도록 구현 해놓은 것
- device controller(디바이스 컨트롤러)
    - I/O 장치를 전담하는 작은 CPU
    - 제어정보를 위한 control, status register 존재
    - 데이터는 로컬버퍼에, 명령은 제어레지스터를 통해서 CPU가 I/O 컨트롤러에게 전달
    - 로컬 버퍼 존재
    - I/O 종료 --> 인터럽트로 CPU에 종료 알림
- DMA controller(컨트롤러)
    - I/O 장치가 인터럽트를 많이 시키니까 CPU를 방해함
    - CPU는 자기일을 하도록하고 I/O장치 로컬버퍼 내용을 메모리에 복사 ---> 완료되면 한번만 CPU에게 보고
- I/O 수행
    - 운영체제를 통해서만 I/O 가능
    - I/O 요청 시 S/W인터럽트
    - I/O 요청 종료 알림 시 I/O 컨트롤러가 H/W 인터럽트 발생시킴
    - 사용자 프로그램은 어떻게 I/O를 하는가?
        - 시스템 콜 
            - 사용자 프로그램이 운영체제하게 I/O 요청(S/W 인터럽트)
            - 운영체제에게 부탁할 때
        - trap을 사용하여 인터럽트 벡터의 특정위치로 이동
        - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
        - 올바른 I/O 요청인지 확인 후 수행
        - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김(H/W가 발생시킨 인터럽트로 CPU에게 알려줌)
- 인터럽트(하드웨어 인터럽트)
    - trap
        - 소프트웨어 인터럽트
        - exception : 프로그램이 오류를 범한 경우
        - system call : 프로그램이 커널 함수 호출하는 경우
    - 인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    - 인터럽트 처리 루틴
        - 해당 인터럽트를 처리하는 커널 함수
        - 인터럽트 처리하는 부분
```
<용어정리>
1. device driver(장치구동기)
- OS 코드 중 각 장치별 처리루틴 ---> S/W

2. device controller(장치제어기)
- 각 장치를 통제하는 작은 CPU ---> H/W
----------------------------------------------------------------
~ 운영체제는 cpU를 사용할 일이 없다
인터럽트가 들어왓을 때만 운영체제에게 넘어가고 그 외에는 계속 사용자가 사용 ~
```
- 동기식 입출력 **<중요, 잘나옴>**
    - I/O 장치까지 가서 직접 읽고 작업
    - I/O가 끝나야 사용자 프로그램에게 넘어감
        - 구현1
            - CPU를 가지고 있으면서 I/O 대기
        - 구현2
            - 다른 프로세스에게 CPU는 주고 I/O 대기
- 비동기식 입출력 **<중요, 잘나옴>**
    - I/O 끝나기 전에 제어가 사용자 프로그램에게 넘어감
- DMA
    - 버퍼에 있는 데이터를 메모리에 COPY
    - 버퍼에 특정 크기(블록 단위)가 쌓이면 한번 CPU에게 인터럽트 걸어서 알려줌
    - 인터럽트 횟수 감소
- 사용자 프로그램이 사용하는 함수
    - 함수
        - 프로세스 내에서 점프
            - 사용자 정의
            - 라이브러리
        - 시스템 콜을 사용
            - 프로세스에서 점프는 불가
            - CPU 제어권을 운영체제 커널에 넘겨서 실행
            - 커널
----
<0417 회의록>
1. 메모리 계층
레지스터 > 캐쉬 > 메인메모리 > 디스크

2. 비동기 입출력이란 무엇인가?
- 동기와 비동기 비교
    - 동기식 : 작업이 완료 되기 전까지 waiting
    - 비동기식 : I/O 작업이 완료되지 않아도 다른일 가능
3. 시스템 콜 종류
> 사용자 프로그램에서 장치에 접근하기 위해 OS에 요청
    - I/O 장치에 관련된 것들이 많다.
    - 파일 생성, 읽/쓰기, 시스템 시간 받기
    - 하드웨어에 접근하는 것들

4. 하드웨어 인터럽트, 소프트웨어 인터럽트

5. 사용자모드, 관리자모드(커널모드)

6. stack, heap 차인
    - stack : 지역변수
    - heap : 동적메모리 