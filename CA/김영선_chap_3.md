## **3.1 ALU 구성 요소**
### **<구성요소>**
1. 산술 연산장치
    - 산술 연산 수행
2. 논리 연산장치
    - 논리연산(AND, OR...) 수행
3. 시프트 레지스터
    - 비트들을 촤, 우로 이동시키는 레지스터
4. 보수기
    - 2진 데이터 ---> 2의 보수(음수화)
5. 상태 레지스터
    - 플래그(연산결과 상태)들 저장 레지스터
    - 같으면 0 다르면 1
---
## **3.2 정수의 표현(중요, 계산 방법)**
### **<음수 표현방법>**
1. 부호화-크기 표현
    - 부호 따로, 크기 따로
    - 실제 시스템에서 사용X ---> 복잡
    - ex) 0 0001001 = 9
          1 0001001 = -9
2. 보수 표현
    - 양수 보수 ---> 음수
    - 음수 보수 ----> 양수
    1. 1의 보수 표현
        - 00001101(+13) ---> 11110010(-13, 보수)
        - 사용 X
    2. 2의 보수 표현
        - 1의 보수 + 1
        - 가장 앞의 숫자(부호비트) = MSB(most significant bit)
        - 가장 뒤의 숫자 = LSB
3. 비트 확장
    - 부호화-크기
        - 부호비트를 맨 앞에 쓰고 나머지 비트 0으로 채우기
        - 00010101 ---> 0000000000010101
    - 2의 보수
        - 부호비트로 나머지 숫자 채우기
        - 11101011 ---> 1111111111101011
---
## **3.3 논리연산**
1. NOT, AND, OR, XOR
    - AND
        - 둘 다 1일 때만 1 출력, 나머지 0
    - OR
        - 둘 중 1일 경우 1출력, 나머지 0
    - XOR
        - 서로 다른 부분만 1 출력
    - NOT
        - 현재 비트와 다른 비트 출력
2. 선택적 세트 연산
    - 필요한 부분만 1로 바꾸고 싶을 때
    - OR 연산
3. 선택적 보수 연산
    - 서로 다른 부분만 1로 바꾸고 싶을 때
    - XOR 연산
    - 이미지에서 어떤 부분은 남기고 반전 가능
4. 마스크 연산(선택적 삭제) 
    - 특정 부분 삭제
    - AND 연산
5. 삽입연산
    - 필요한 부분 삽입
    - 특정 부분 삭제
        - 마스크 연산(AND)
    - 새로 삽입
        - OR 연산 
6. 비교 연산
    - 비교
    - XOR 연산
    - '결과값 != 0' ----> 두 비트는 서로 다르다. Z 플래그 1
---
## **3.4 시프트 연산(>>, <<)**
1. 논리적 시프트(이동)
    - 숫자 크기에 상관없음, 단순 이동
    1. 좌측
        - 모든 비트들 좌측으로 한칸 이동
        - 맨 앞 비트 버림, 맨 뒤 비트 0 
    2. 우측
        - 모든 비트들 우측으로 한칸 이동
        - 맨 앞 비트 0, 맨 뒤 비트 버림
    3. 순환 시프트(순환)
        - 좌측
            - 맨 앞 비트 ---> 맨 뒤 비트
        - 우측
            - 맨 뒤 비트 ---> 맨 앞 비트
    4. 직렬 데이터 전송
        ```
        - 병렬처리를 직렬처리로 바꿀 때 사용
        - 병렬은 내부에서 사용
        - 내부에서 외부로 나갈 때 직렬 전송
        ```
        - 우측 시프트 제어 신호일경우(내부:왼쪽, 외부:오른쪽)
            - 외부 레지스터 : 우측 시프트
            - 내부 레지스터 : 우측 순환 시프트
2. 산술적 시프트
    - C언어 >>, <<
    - 부호 불변, 크기 변동
3. C(carry) 플래그를 포함한 시프트
    - carry는 상태 레지스터 안에 존재
    - 버리지 않고 carry로 보낸다 / 계산된 결과가 carry로 들어간다.
    - 더 큰 숫자 계산을 위해 사용
    - 좌측, 우측, 좌측 순환, 우측 순환
---
3.5 정수의 산술연산
> 2의 보수 사용하여 계산
1. 덧셈
    - 2의 보수
        - 버린 수 ---> carry로 이동
        - 1010 + 0010 = 1100 ---> -8+4 = -4
        - 1100 + 1111 = 1011 ---> -8+3 = -5
    - 병렬 가산기
        - 전가산기들로 구성
        - 연산 결과 플래그들
            - C 플래그 : 올림수
            - S 플래그 : 부호
            - Z 플래그 : 모든 비트 0이면 1
            - V 플래그 : 오버플로우, 최종 캐리와 직전 캐리가 서로 다를 때 1, XOR 연산
    - 덧셈 오버플로우
        - 덧셈 겨로가가 범위를 초과하여 결과값이 틀리게 되는 상태
        - 0110 + 0011 = (0)1001 = -7 ----> 직전 캐리(올림수) = 1, 최종 캐리 = 0 ---> 오버플로우
2. 뺄셈
    - 실제로 컴퓨터는 수행하지 않음
    - 덧셈으로 변환(보수기 이용(ALU 내부))
    - (+2)-(+6) = (+2)+(-6) = 0010+1010 = 1100 = -4
    - 뺄셈 오버플로우 
        - 뺄셈 결과가 범위를 초과하여 결과값이 틀리게 되는 상태
        - 오버플로우 여부는 알 수 있으나 최종 결과는 알 수 없음
---
## **3.6 부동소수점 수의 표현**
```
> IEEE 754 사용하여 계산
- 단일 정밀도(32비트) - FLOAT
- 복수 정밀도(64비트) - DOUBLE
```
- 정규 표현식 : 0.1xxx X 2<sup>N<sup>
    
### **<단일 정밀도(32비트)>**
1. 부호비트(1비트) + 지수필드(8비트, E) + 가수필드(23비트, M)
2. 지수필드 비트증가 ---> 표현 범위 확장
3. 가수필드 비트증가 ---> 소수 이하에 포함되는 숫자 증가 ---> 정밀도 증가
4. 문제점 : 지수에 부호를 나타낼 수 x
5. 바이어스된 수 
    - 지수 부호 표시 위해 사용
    - 바이어스 값=0, 절대값=127, 지수패턴=01111111 ---> 이것보다 위일 경우 양수, 아래일 경우 음수
    ```
    - ex) 바이어스값 = 128, N = -13.625
        - 13.625 = 1101.101 = 0.1101101 * 2^4
        - 부호 비트 = 1(-)
        - 지수 = 00000100(4) + 10000000(128) = 10000100(+4)
        - 가수 = 10110100000000000000000 ---> 소수점 우측 첫번째 1(hidden bit, 0.1)은 제외
    ```
6. 범위
    ```
    N < (-2^127) : 음수 오버플로우 --> ERR : INF
    N > 2^127 : 양수 오버플로우 ---> ERR : INF
    N > (-2^-128) : 음수 언더플로우 --> -0
    N < (2^-128) : 양수 언더플로우 ---> +0
    ```
### **<IEEE 754 표준 부동소수점>**
1. hidden bit = 1
2. 바이어스 = 127
3. 정규 표현식 : 1.xxx X 2<sup>N<sup>
```
- ex) 바이엇값 =127, N=0.3 
    - 0.3 = 0.010011001100....(0.3에 계속 2곱하기) = 1.00110011...*2^-2
    - 부호비트 = 0
    - 지수 = 00000010 + 01111111 = 01111101
    - 가수 = 001100110011....
```
### **<산술연산>**
1. 덧셈 & 뺄셈
    - 지수 일치시킨 후 가수들 더하기 ---> 정규화(1.xxx X 2<sup>N<sup>)
2. 곱셈
    - 가수 곱하기 ---> 지수 더하기 ---> 정규화
3. 나눗셈
    - 가수 나누기 --> 지수 빼기 ---> 정규화
4. 부동소수점 산술 파이프라이닝 ---> 계산 속도 향상

### **<문제점>**
1. 지수 오버플로우/언더플로우
---> 무한대/0으로 표시
2. 가수 오버플로우/언더플로우
---> 반올림 적용/지수 조정
