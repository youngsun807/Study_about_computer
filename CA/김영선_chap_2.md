## **2.1 CPU 기본구조**
### **<CPU 기능>**
- 모든 명령어 공통 수행
    1. 명령어 인출 :  기억장치로부터 명령어 읽기
    2. 명령어 해독 : 명령어를 해독해서 수행할 동작 결정
- 명령어에 따라 필요한 경우에 수행
    1. 데이터 인출 : 기억장치, I/O장치로부터 데이터 읽기
    2. 데이터 처리 : 산술적, 논리적 연산 수행
    3. 데이터 쓰기 : 수행결과 저장
### **<CPU 기본구조>**
1. 산술논리연산장치(ALU)

2. 레지스터 세트
    - CPU가 데이터 처리 과정에서 필요한 데이터를 잠시 보관
    - CPU 속 메모리 ---> 기억장치 중 가장 access 속도 빠름, 저용량
    - 레지스터 수 제한
3. 제어 유닛
    - 명령어들 해독
    - 해독 결과에 따라 여러 장치 제어
4. CPU 내부 버스
    - 데이터 이동
    - 제어 신호 이동
    - 외부 시스템 버스들과 직접 연결 X ---> 버퍼 레지스터, 시스템 버스 인터페이스 회로 통해 접속
---
## **2.2 명령어 실행**
### **<명령어 사이클>**
>CPU가 한 개의 명령어 실행하는데 필요한 전체 처리 과정
1. 부사이클
    - 인출 사이클 : CPU가 기억장치로부터 명령어 읽는 단계
    - 실행 사이클 : 명령 실행 단계, 명령어 해독 및 연산 수행
2. 인터럽트 사이클
    - 인터럽트 : 프로그램 실행 중 CPU의 현재 처리 중단, 다른 동작 수행하도록 함
3. 다중 인터럽트
    - 인터럽트 서비스 루틴 수행 중 다른 인터럽트 발생
    - 인터럽트 우선순위 설정 --> 더 높은 우선순위부터 처리
4. 간접 사이클(ex - 포인터)
    - 명령어에 포함된 주소 이용하여 주소 내의 데이터 가져오기
    - 인출 사이클, 실행 사이클 사이에 위치
### **<CPU 내부 레지스터>**
1. 프로그램 카운터(pc)
    - 바로 다음에 실행될 명령어 주소 보유
2. 누산기(AC)
    - 데이터 일시 저장
    - 크기 : CPU가 한번에 처리될 수 있는 데이터 비트수(word 길이)
3. 명령어 레지스터(IR)
    - 가장 최근 읽어온 명령어 저장
4. 기억장치 주소 레지스터(MAR)
    - pc내 메모리 주소를 내보낼 때 저장 주소 임시저장
5. 기억장치 버퍼 레지스터(MBR) 
    - 기억장치에 있는 주소를 읽어서 가져올 때 읽은 데이터 임시 저장
---
## **2.3 명령어 파이프라이닝**
> CPU 처리속도를 높이기 위해 내부 하드웨어를 여러단계로 나누어 동시처리 기술<br>
  ----> CPU clock 높이는데 한계가 있어서 유지한 상태에서 속도 높이는 방법
```
1. [2단계] 명령어 파이프라인
    - 인출 단계, 실행 단계 2개 ---> 두 개의 독립적인 하드웨어 구성
    - 시간 흐름도 : 인출하면 인출된걸 실행 + 다음 명령어 인출
    - 속도 2배 향상
    - 문제점 : 두단계의 처리시간이 동일하지 않으면 속도가 비례하지 못함
    - 해결방안 : 파이프라인 단계 수 증가 ---> 각 단계의 처리 시간 같게 함

2. [4단계] 명령어 파이프라인
    - 명령어 인출(IF) : 다음 명령어 기억장치로부터 인출
    - 명령어 해독(ID) : 명령어 해석
    - operand 인출(OF) : 기억장치로부터 operand 인출
    - 실행(EX) : 지정된 연산 수행
    - 시간 흐름도 : 실행을 제외한 단계가 계속 겹치면서 진행
```
### **<파이프 라인의 전체 명령어 실행시간>**
```
* n(파이프라인 단계) = k
* n(실행 명령어) = N
* 가정 : 파이프라인 1단계 = 클럭 1주기
```
1. 파이프라인 경우
    ```
    T = k + (N-1) 
    ---> 첫번째 명령어 = k주기, 나머지(N-1) = 1주기
    ```
2. 파이프라인 아닌 경우
    ```
    T = k * N
    ```
3. 파이프라인에 의한 속도 향상
    ````
    Sp = T1/Tk = k*N/k*(N-1)
    ```

### **<파이프라인 클록>**
```
처리시간이 가장 오래 걸리는 단계 기준으로 결정
```
### **<파이프라인 효율저하 요인>**
1. IF 단계와 OF 단계 동시에 기억장치로 access ---> 기억장치 충돌 ---> 지연발생
2. 조건 분기 실행 ---> 미리 인출하여 처리하던 명령어 무효
### **<해저드(장애물)>**
> 파이프라인, 슈퍼스칼라에서 발생할 수 있는 문제점들<br> ---> 계산 결과 오류 발생
- 종류
    1. 데이터 헤저드 : 실행 순서에 따른 문제
        > 서로 단계에서 데이터들끼리 충돌, 의존성이 존재할 때 발생
        - 문제 : 경쟁조건
        - 발생 가능 상황
            1. read after write(RAW)
                - 참의존성
                - 발생할 가능성 가장 높음
                - 해결방법
                    1. 파이프라인에 NOP(앞의 명령어가 끝날때까지 멈춰있기)을 끼워넣기 ---> 파이프라인 버블링
                    2. 파이프라인 스톨
                    3. 명령어 재배치 ---> 컴파일러 역할 ---> S/W적 문제
            2. write after read(WAR), write after write(WAW)
                - 레지스터 renaming(레지스터 이름 바꾸기) ---> 하드웨어적 방법(OS), 컴파일러 ---> 여분의 레지스터 필요 ---> 많은 레지스터 필요
    2. 구조적 해저드 : 하드웨어적 설계에서 문제, 파이프라인으로 인해서 발생 가능
        > 동시에 두 개 이상의 명령이 하드웨어의 한부분을 사용하려고 할 때 발생
        - 해결방법
            1. case1: 명령어 인출, 데이터 인출 동시 발생
                1. 메모리장치 분리 : 메모리장치 내에서 명령어 저장위치와 데이터 저장위치 분리 ---> 하버드 아키텍처
                2. 캐시 분리 : 명령어 캐시와 데이터 캐시 분리
                3. 파이프라인 버블링 ---> 파이프라인 의미 없어짐
            2. case2: CPU 내 장치에서 충돌 발생
                - 장치 추가 (ex) ALU 2-3개 두기
        
    3. 제어 해저드, 분기 해저드 (ex) if, for, loop에서 문제 발생
        > 분기로 인해 발생 가능
        - 예시 : if, for, loop, continue, function...
        - 성능 저하 최소화방법
            1. 분기예측
                - 분기 역사 표 이용
            2. 분기 목적지 선인출
                - 조건 분기 인식되면 목적지 명령어도 함께 인출
            3. 루프 버퍼
                - 미리 가져와서 읽어오는 시간 단축
            4. 지연 분기
                - 명령어 위치 재배치 --> 컴파일러
- 처리방법
    1. 파이프라인 스톨(멈추는 것)
    2. 파이프라인 버블링(명령어 끼워넣기)
    3. 레지스터 포워딩
    4. 비순서적인 실행(순서 바꾸기/ex-스코어보딩, 토마슬로 알고리즘)
- 상태 레지스터

    - 조건분기 명령어가 사용할 조건플래그들 저장

### **<슈퍼스칼라>**
> 두 개 이상의 파이프라인 포함 = 똑같은 생산라인 두 개 이상
- 각 파이프라인 동시 실행 가능 ---> 파이프라인 수(m)만큼 속도 향상 ---> m-way 슈퍼스칼라
- m-way 슈퍼스칼라 실행시간
    ```
    T(m) = k + N-m/m
    ```
- 속도향상
    ```
    Sp = T(1)/T(m) = (k+N-1)/(k+N-m/m) = m(k+N-1)/N+m(k-1)
    ```
- 속도 저하 요인 : 위에 언급한 3개 해저드
- 해결방안
    1. 명령어 실행순서 재배치 : 명령어들 간 데이터 의존성 제거 ---> 컴파일러
    2. 하드웨어 추가(중복) : 기억장치 및 레지스터 경합 감소
- 듀얼코어 & 멀티코어
---
## **2.4 명령어 세트(ISA)**
> 명령어들의 집합
### **<명령어 세트 설계(CPU 설계) 위한 결정사항들>**
1. 연산종류 : 연산수, 종류, 복잡도
    1. 데이터 전송 : 데이터 이동
    2. 산술연산 : 사칙연산
    3. 논리연산 : 비트연산, AND/OR/NOT...
    4. I/O
    5. 프로그램 제어 : 명령어 실행 순서 변경
        1. 분기
        2. 서브루틴 호출
            - 같은 코드 반복할 경우 호출만 해서 사용 ---> 함수
            1. call 명령어 : 프로그램 실행 관련 모든 것 저장
            2. ret 명령어 : 원래 실행하던 프로그램으로 복귀
2. 데이터 형태 : 데이터 형태, 데이터 길이(비트수), 수의 표현방식
3. 명령어 형식 : 명령어 길이, operand 필드 수와 길이
    - 구성요소
        1. 연산코드
        >수행될 연산 지정
        2. operand(피연산자)
        >연산 수행에 필요한 데이터 or 데이터 주소
        3. 다음 명령어 주소
        >다음 명령어 위치 지정
    - 명령어 형식 결정시 고려사항들
        - 연산코드 필드 길이
        - operand 필드 길이
    - operand 수에 따른 명령어 분류
        1. 0주소 명령어
        2. 1주소 명령어 : AC 같이 사용
        3. 2주소 명령어
        4. 3주소 명령어
4. 주소지정 방식 : operand 주소 지정방식
    ``` 
    사용이유 : 제한된 수의 명령어 비트들을 이용하여 더 큰 용량의 기억장치를 사용하기 위해서
    ```
    1. 직접 주소지정 방식
        > operand 필드 내용 = 실제 사용데이터 저장 위치
        - 장점 : 기억장치에 한번만 access
        - 단점 : 연산코드 이외 비트들만 주소비트 사용---> 기억장소 수 제한
    2. 간접 주소지정 방식

        > 메모리에 여러번 access ---> 전체 속도 저하
    3. 묵시적 주소지정 방식
        > 데이터 위치를 묵시적으로 지정
        - 장점 : 짧은 명령어 길이
        - 단점 : 종류 제한
    4. 즉치 주소지정 방식
        > operand 값 = 상수값
        - 장점 : 데이터 인출 X -- 기억장치 access 필요 없음
        - 단점 : 상수값 크기가 operand 필드 비트수에 의해 제한
    5. 레지스터 주소지정 방식
        > 사용할 데이터가 레지스터에 저장되어 있음
        - 장점 : operand 비트수 적어도 됨, 기억장치 access 필요 X
        - 단점 : CPU 내부 레지스터 제한 ---> 저장공간 제한
    6. 레지스터 간접 주소지정 방식
        > operand 필드 내용 -> 레지스터 내에 주소 -> 기억장치 access
        - 장점 : 기억장치 영역 확장
        - 레지스터 길이 = 주소지정 영역
    7. 변위 주소지정 방식
        > 직접 주소방식 + 레지스터 간접 주소방식
        - 종류
        1. PC - 상대 주소지정
            > 프로그램 카운터(PC)를 레지스터로 사용
            - 장점 : 일반적인 분기 명령어보다 적은 수의 비트
            - 단점 : 분기 범위가 operand 필드 길이에 의해 제한
        2. 인덱스 레지스터 - 인덱스 주소지정
            > 자동 인덱스

            - 장점 : 명령어 길이 축소, 쉽게 access
        3. 베이스 레지스터 - 베이스 레지스터 주소지

            > 베이스 레지스터 내용 + 변위 A
