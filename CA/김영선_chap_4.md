## **4.1 제어 유닛 기능**
> 명령어 해독(opcode), 명령어 실행에 필요한 제어 신호 발생
1. 마이크로프로그램 control
    - S/W적으로 구성
    - 마이크로명령어 : 기게명령어 보다 작음
2. Hardwired control
    - H/W적으로 구성
    - 게이트들을 엮어서 하나의 시스템 생성 ---> 설계 이후 변경 어려움 ---> 작은 시스템에서 변경 없을 경우 사용
3. 루틴
---
## **4.2 제어 유닛 구조**
1. 구성요소들
    - 명령어 해독기
        - opcode 해독
        - 제어루틴 시작주소 결정
        - 제어신호 발생
    - 제어 주소 레지스터(control address register, CAR)
        - 다음 실행할 주소 임시 저장
    - 제어 기억장치
        - 마이크로 명령어 저장하는 내부 기억장치(ROM)
    - 제어 버퍼 레지스터(control buffer register, CBR)
        - 마이크로 명령어 임시 저장
    - 서브루틴 레지스터(subroutine register, SBR)
        - 서브루틴 호출 ---> 현재 CAR 내용 임시저장
    - 순서제어 모듈
        - 명령어 순서 결정하는 회로집합
2. 명령어 세트 설계 과정
    1) 명령어 종류, 비트패턴 정의
    2) 명령어 실행에 필요한 H/W 설계
    3) 각 명령어를 위한 실행사이클 루틴 작성
    4) 마이크로프로그램 코드들을 제어 기억장치에 저장
3. 명령어 해독
    - mapping
        - opcode를 특정 비트 패턴과 조합
        - 0110 ---> 1011000 : 맨앞에 1, 맨 뒤에 00이 붙임
---
## **4.3 마이크로명령어 형식**
> 연산필드 2개 ---> 마이크로 연산 2개 동시 수행
1. 조건필드
    -분기에 사용될 조건 플래그 지정(2비트)
2. 분기필드
    - 분기 종류
    - 다음에 실행할 마이크로명령어 주소 결정 방법 명시, 
    - 분기 동작 지정(2비트)
    - 조건 필드 만족되면 ADF 필드의 내용을 CAR로 적재 ---> 그 주소로 분기(JUMP, CALL)
3. 주소필드(ADF)
    - 분기 발생 시 목적지 마이크로명령어 주소 사용
---
## **4.4 마이크로프로그래밍**
1. 인출 사이클 루틴
    ```
            ORG0                     : 0번지부터 시작
    FETCH   PCTAR       U   JMP NEXT : MAR <- PC, 다음 명령어 실행
            READ, INCPC U   JMP NEXT : BR <- M[MAR], PC=PC+1, 다음 마이크로명령어 실행
            BRTIR       U   MAP      : IR <- MBR, 해당 실행 사이클 루틴으로 분기
    ```
2. 간접 사이클 루틴
    ```
            ORG4                 : 4번지부터 시작
    INDRT   IRTAR   U   JMP NEXT : MAR <- IR(addr), 다음 명령어 실행
            READ    U   JMP NEXT : MBR <- M[MAR], 다음 명령어 실해
            BRTIR   U   RET      : IR(addr) <- MBR, 실행 사이클 루틴으로 복귀
    ```
3. 실행 사이클 루틴
    - mapping을 이용하여 루틴 시작주소 결정, 명령어 실행 위한 루틴 작성
    - NOP, LOAD, STORE, ADD, SUB, JUMP
---
## **4.5 마이크로프로그램 순서제어**
> 다음 실행할 명령어 주소 결정
1. CAR 초기값 = 0
2. MUX1
    - 다음실행할 주소 선택
3. MUX2 
    - 조건 플래그 선택
    - 주소선택 회로로 전송
4. 제어신호 생성
    - 명령어 레지스터의 opcode가 입력이 되고 외부로 출력
5. 종류
    1. 수직적 마이크로프로그래밍
        - 연산필드 ---> 적은 수의 코드화된 비트들
        - 해독기를 통해서 그 비트들의 필요한 수 만큼 명령어 나옴
            3 TO 8 ---> 3*8해독기
        - 장점 : 명령어 길이(비트수) 최소화 ---> 제어 기억장치 용량 감소
          단점 : 해독 동작에 결리는 만큼 지연
    2. 수평적 마이크로프로그래밍
        - 연산필드 비트
            - 제어신호 = 1:1
        - 8 TO 8
        - 장점
            - 하드웨어 간단
            - 해독 지연시간 x
        - 단점
            - 비트 길이 증가 ---> 제어 기억장치 용량 증가
          